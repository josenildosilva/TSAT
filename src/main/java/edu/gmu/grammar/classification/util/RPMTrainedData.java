package edu.gmu.grammar.classification.util;

import edu.gmu.grammar.classification.GCProcessMultiClass;
import edu.gmu.grammar.patterns.BestSelectedPatterns;
import edu.gmu.grammar.patterns.PatternsSimilarity;
import edu.gmu.grammar.patterns.TSPattern;
import net.seninp.jmotif.sax.NumerosityReductionStrategy;

import java.io.Serializable;
import java.util.List;
import java.util.Map;

/**
 * Created by David Fleming on 12/2/16.
 *
 * This class stores the trained model from RPM and is used to load back the model for further testing
 */
public class RPMTrainedData implements Serializable {

    private static final long serialVersionUID = -5673240879243466426L;

    // The trained window size, paa, and alphabet. Generated by RPM
    public int windowSize;
    public int paa;
    public int alphabet;

    // The best representative patterns for classes that RPM found
    public BestSelectedPatterns[] bestSelectedPatternsAllClass;

    // Path to the training data
    public String training_data_path;
    // The training data (Not saved in file)
    public transient Map<String, List<double[]>> trainData;

    // The strategy used in string format
    public String allStrategy;

    // The upper and lower bounds for window, paa, and alphabet
    public int[] upperBounds;
    public int[] lowerBounds;

    // RPM parameters
    public int folderNum;
    public double rpFrequencyTPer;
    public int maxRPNum;
    public double overlapTPer;
    public Boolean isCoverageFre;

    public double pSimilarity;

    // The maximum number of iterations RPM will run through
    public int iterations_num;

    /**
     * This function can be used to reduce the best selected patterns from RPM in a representative set
     * @return - A set of patterns the are best for representing the classes
     */
    public TSPattern[] finalPatterns() {
        GCProcessMultiClass gcp = new GCProcessMultiClass(this.folderNum);
        return gcp.combinePatterns(this.bestSelectedPatternsAllClass);
    }

    public double[][] getFeatureVector(Map<String, List<double[]>> dataset, ClassificationResults results) {
        GCProcessMultiClass gcp = new GCProcessMultiClass(this.folderNum);
        TSPattern[] finalPatterns = gcp.combinePatterns(this.bestSelectedPatternsAllClass);
        return gcp.transformTSWithPatternsTest(finalPatterns, dataset, results);
    }

    /**
     * Convenient way to get the information stored in the model
     * @return - A formatted string suitable for printing
     */
    @Override
    public String toString() {
        StringBuilder output = new StringBuilder();
        output.append("Train Data Path: " + this.training_data_path + "\n");
        output.append("Windows Size: " + this.windowSize + "\n");
        output.append("PAA: " + this.paa + "\n");
        output.append("Alphabet: " + this.alphabet + "\n");
        output.append("Best Patterns All Classes: \n");
        TSPattern[] patterns = this.finalPatterns();
        for(int i = 0; i < patterns.length; i++) {
            output.append(patterns[i].toString() + "\n");
        }

        return output.toString();
    }

}
